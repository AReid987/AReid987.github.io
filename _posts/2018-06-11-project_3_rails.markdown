---
layout: post
title:      "Project 3 : Rails "
date:       2018-06-12 02:35:30 +0000
permalink:  project_3_rails
---


For this portfolio project, I decided to go with a recipe organizer application. I began the process by reviewing the Rails section, and my notes on the section. Once I had organized a plan, I started to code the User sign up, sign in, and logout process. After generating the User model, I added the appropriate columns to the migration file for Users, along with the routes through the resources macro. Then, it was time for the sessions controller. Following the style guide and reviewing my code from previous labs made it fairly straightforward. However, when I added facebook login with omniauth, I ran into an issue. Since passwords are required for signup, I had to create a class method for the User model in order to generate a random password upon signing up with facebook. 

When it came to the structure for this app, I went with a bootstrap template. I was searching google for how to use bootstrap with Rails, and came across a great tutorial. I decided to use the free template, which actually came with some JavaScript files. I incorporated some of the template and made some adjustments to fit the scope of this project. I used a partial for the header to encapsulate the home button, and the sign in/sign up links. Another partial was used to create a sidebar for links to recipe controller actions. It helped to visually group links to the same controllers. In each of those partials, I made use of some helper methods defined in the application controller. #current_user handles introspecting on the session hash to find a User based on the value of session[:user_id]. If there is a current user, the header renders a user-menu partial instead of the sign up/sign in links. This user-menu uses javaScript to dropdown onclick and renders the links to log out, the user's profile as well as displays some User information. The sidebar also, uses a similar conditional logic to change with links are rendered. If a user is logged in, they will see links to create a new recipe and to view their own recipes.

With Users and Sessions in place, the next step was to create the Recipe model, database table and controller. 
I also added routes for :recipes and included nested :recipes resources. At first I just worked out creating a recipe with a name and set of instructions only. I set the associations as User has_many :recipes and a Recipe belongs_to :user. I used the standard conventions and RESTful routes to achieve the new, create, edit, update and destroy actions for recipes. The #current_user helper method was used to display or not display edit and destroy options in the show page for recipes. 

I ran into some serious challenges when it came to adding Ingredients to recipes. Since a recipe should only exist once in the database, I was unsure how to go about adding Quantities to Ingredients. Since there was a many_to_many between Ingredients and Recipes, I added Items for a join model. I did the standard generators for an Ingredients model and database table. There was no need for an ingredients controller. I also did the same for Items. An Ingredient has many Items, which belongs to an Ingredient. The same is true for Recipes and Items. The Item, since it exists only one per Ingredient and Recipe holds the quantity. I Used the cocoon gem to add form fields on the fly, which enables a link_to_add_association form helper method, along with a link_to_remove_association method. There was a double nesting that had to happen in order to get the params hash to work as needed. Then inside my strong params, I needed to follow the same pattern of nesting another key pointing to an array for items_attributes. In the Recipe model, I used accepts_nested_attributes_for as I also did in the Item model.  In this way I was able to create a custom association writer for ingredients_attributes in the Recipe model, that could introspect on params and create the proper associations from the form submission on recipes/new. It of course had to be refactored when I got to the edit action to incorporate functionality for Recipes that already exist. This was actually hard to search for and so I spent quite a lot of time on google, stackoverflow, the Rails documentation, etc. It was very satisfying to solve! 

There are some other details in the code, such as before actions and authentication. Most of it was very straightforward and done according to conventions learned in previous lessons and the documentation. 

The next challenge was in implementing the class level ActiveRecord scope method.  I hadn't actually declared a scope in any of my labs so far, which meant some research and review was in order. Since a scope with alway return an ActiveRecord Relation Object, I chose that over simply defining a class method. I went with returning the User with the most_recipes. The process for crafting the query was to use the rails console and work until I got the object I was looking for. However, the method returned a collection, so it took some time before I realized I need to chain a call to #first to the end of #most_recipes in order to render an actual object in a view. After get the scope to return the correct record, I add a route and controller action for #most_recipes. A link in the index view takes you to the user and shows their recipes. 

I found this very challeging and extremely useful for cementing concepts that I had some difficulties with. I especially had a hard time with associations, but I feel much more comfortable using them now. I am very much looking forward to JavaScript and being able to use Rails and JavaScript together. 
